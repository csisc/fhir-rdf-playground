#!/usr/bin/env node

const Fs = require('fs');
const Path = require('path');
const FhirShExJGenerator = require('../FhirShExJGenerator.js');

const GEN_SHEXJ_CONTEXT_CONFIG = {
  addValueSetVersionAnnotation: false, // handle e.g. "http://hl7.org/fhir/ValueSet/medicationrequest-status|4.6.0"
  oloIndexes: true,
};

const GEN_SHEXJ_STEM = 'http://hl7.org/fhir/StructureDefinition/';
const CODE_SYSTEM_STEM = 'http://hl7.org/fhir/CodeSystem/';
const VALUE_SET_STEM = 'http://hl7.org/fhir/ValueSet/';
const CAPABILITY_STATEMENT_BASE = 'http://hl7.org/fhir/CapabilityStatement/';
const COMPARTMENT_DEFINITION_BASE = 'http://hl7.org/fhir/CompartmentDefinition/';
const OPERATION_DEFINITION_BASE = 'http://hl7.org/fhir/OperationDefinition/';

const indexFhir = (acc, entry) => {
  acc[entry.resource.id] = entry.resource;
  return acc;
};

generate(process.argv.slice(2));

async function generate([resources, datatypes, valuesets, got]) {
  // Generate in memory
  // const generator = new FhirShExJGenerator(FHIRStructureMap, FHIRDatatypeMap);
  const parsedResources = await readJsonProfile(resources);
  const parsedDatatypes = await readJsonProfile(datatypes);
  const parsedValuesets = await readJsonProfile(valuesets);
  const generator = new FhirShExJGenerator(
      parsedResources.entry.reduce(indexFhir, {}),
      parsedDatatypes.entry.reduce(indexFhir, {}),
      parsedValuesets.entry.reduce(indexFhir, {}),
      GEN_SHEXJ_CONTEXT_CONFIG
  );
  const sources = [parsedResources, parsedDatatypes, parsedValuesets];
  const errors = [];
  const generated = sources.reduce((generated, source) => {
    return source.entry.reduce((generated, entry) => {
      const url = entry.fullUrl;
      if (url.startsWith(CAPABILITY_STATEMENT_BASE) ||
          url.startsWith(COMPARTMENT_DEFINITION_BASE) ||
          url.startsWith(OPERATION_DEFINITION_BASE) ||
          url === GEN_SHEXJ_STEM + 'Base' ||
          url === CODE_SYSTEM_STEM + 'FHIR-version') // no use for these at present
        return generated;

      const genMe = url.startsWith(GEN_SHEXJ_STEM)
          ? url.substr(GEN_SHEXJ_STEM.length)
          : url.startsWith(VALUE_SET_STEM)
              ? url.substr(VALUE_SET_STEM.length)
              : url.substr(CODE_SYSTEM_STEM.length);
      try {
        source.id === 'valuesets'
            ? generator.genValueset(genMe, GEN_SHEXJ_CONTEXT_CONFIG)
            : generator.genShape(genMe, true, GEN_SHEXJ_CONTEXT_CONFIG);
        return generated.concat(genMe);
      } catch (e) {
        errors.push(e);
        return generated; // tolerate e.g. missing valuesets
      }
    }, generated);
  }, [])
  const allTypesLabel = Prefixes.fhirvs + 'all-types';
  generated.push('all-types');
  generator.genAllTypes(allTypesLabel, GEN_SHEXJ_CONTEXT_CONFIG);
  const ret = generator.schema;

  await writeShExJ(got, ret, true); // TODO: add switch for pretty-printing
  console.log(`wrote ${ret.shapes.length} shape expressions into ${got}`);
  if (errors.length) {
    console.log(`writing ${errors.length} errors to stderr`);
    errors.forEach(e => console.warn("error trying to genShExJ:" + e.stack));
  }
};

// Write to disk with long-lines
async function writeShExJ(filename, schema, longLines) {
  const head = `{
  "type": "Schema",
  "shapes": [
`;
  const tail = `  ],
  "@context": "http://www.w3.org/ns/shex.jsonld"
}
`;
  await Fs.promises.writeFile(
      filename,
      longLines
          ? head + schema.shapes.map((se, idx) => JSON.stringify(se) + (idx === schema.shapes.length - 1 ? '' : ',') + '\n').join('') + tail
          : JSON.stringify(schema, null, 2)
  );
}

async function readJsonProfile (path) {
  const text = await Fs.promises.readFile(path, 'utf8');
  const obj = JSON.parse(text);
  return obj;
}
